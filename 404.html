<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 - Page Not Found | Amanda Harnett</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sand: #D4A574;
            --sand-light: #E8C5A0;
            --sand-dark: #9E7E54;
            --blush: #E89B9B;
            --sky: #87CEEB;
            --sky-light: #B0E0E6;
            --white: #FFFFFF;
            --black: #0A0A0A;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: linear-gradient(180deg, var(--sky) 0%, var(--sky-light) 60%, var(--sand-light) 60%, var(--sand) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            padding: 2rem;
        }

        h1 {
            font-size: 4rem;
            color: var(--blush);
            text-shadow: 3px 3px 0 var(--white);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--sand-dark);
            margin-bottom: 1.5rem;
        }

        #gameCanvas {
            border: 4px solid var(--sand-dark);
            border-radius: 8px;
            background: linear-gradient(180deg, var(--sky) 0%, var(--sky-light) 70%, var(--sand-light) 70%, var(--sand) 100%);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            cursor: pointer;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .instructions {
            margin-top: 1rem;
            color: var(--sand-dark);
            font-size: 0.9rem;
        }

        .instructions span {
            background: var(--white);
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            border: 2px solid var(--sand);
            margin: 0 0.3rem;
        }

        .score-display {
            font-size: 1.5rem;
            color: var(--blush);
            margin-top: 1rem;
            text-shadow: 2px 2px 0 var(--white);
        }

        .home-link {
            display: inline-block;
            margin-top: 1.5rem;
            padding: 0.8rem 2rem;
            background: linear-gradient(135deg, var(--sand) 0%, var(--sand-light) 100%);
            color: var(--white);
            text-decoration: none;
            border-radius: 4px;
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .home-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 165, 116, 0.4);
        }

        .game-over-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: var(--blush);
            background: rgba(255,255,255,0.9);
            padding: 1rem 2rem;
            border-radius: 8px;
            display: none;
        }

        @media (max-width: 700px) {
            #gameCanvas {
                width: 100%;
                height: auto;
            }
            h1 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>404</h1>
        <p class="subtitle">Oops! This page took a dive in the sand.</p>
        
        <canvas id="gameCanvas" width="640" height="280"></canvas>
        
        <p class="instructions">
            Press <span>SPACE</span> or <span>TAP</span> to jump over the nets!
        </p>
        
        <div class="score-display">
            Score: <span id="score">0</span> | Best: <span id="highScore">0</span>
        </div>
        
        <a href="index.html" class="home-link">‚Üê Back to Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');

        // Game constants
        const GROUND_Y = 220;
        const GRAVITY = 0.8;
        const JUMP_FORCE = -14;
        const GAME_SPEED_INITIAL = 5;
        const GAME_SPEED_INCREMENT = 0.001;

        // Colors (matching site palette)
        const COLORS = {
            sky: '#87CEEB',
            skyLight: '#B0E0E6',
            sand: '#D4A574',
            sandLight: '#E8C5A0',
            sandDark: '#9E7E54',
            blush: '#E89B9B',
            white: '#FFFFFF',
            sun: '#FFD700',
            sunGlow: '#FFA500',
            maple: '#FF0000',
            net: '#FFFFFF',
            netPole: '#8B4513'
        };

        // Game state
        let gameState = 'waiting'; // waiting, playing, gameOver, won
        let score = 0;
        let highScore = parseInt(localStorage.getItem('amandaGameHighScore')) || 0;
        let gameSpeed = GAME_SPEED_INITIAL;
        let frameCount = 0;

        // Amanda (player)
        const amanda = {
            x: 80,
            y: GROUND_Y,
            width: 32,
            height: 48,
            velY: 0,
            isJumping: false,
            frame: 0,
            
            draw() {
                ctx.save();
                
                // Body (sand/tan color like volleyball player)
                ctx.fillStyle = '#F5D5C8';
                ctx.fillRect(this.x + 8, this.y + 12, 16, 20);
                
                // Head
                ctx.fillStyle = '#F5D5C8';
                ctx.fillRect(this.x + 8, this.y, 16, 14);
                
                // Hair (blonde ponytail)
                ctx.fillStyle = '#F4D03F';
                ctx.fillRect(this.x + 8, this.y, 16, 6);
                ctx.fillRect(this.x + 20, this.y + 2, 8, 8); // ponytail
                // Hair highlight
                ctx.fillStyle = '#F9E076';
                ctx.fillRect(this.x + 10, this.y + 1, 6, 3);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 10, this.y + 6, 3, 3);
                ctx.fillRect(this.x + 17, this.y + 6, 3, 3);
                
                // Smile
                ctx.fillRect(this.x + 12, this.y + 10, 6, 2);
                
                // Tank top (blush pink)
                ctx.fillStyle = COLORS.blush;
                ctx.fillRect(this.x + 8, this.y + 14, 16, 10);
                
                // Shorts (sand color)
                ctx.fillStyle = COLORS.sandDark;
                ctx.fillRect(this.x + 8, this.y + 24, 16, 8);
                
                // Legs (running animation)
                ctx.fillStyle = '#F5D5C8';
                if (this.isJumping) {
                    // Tucked legs when jumping
                    ctx.fillRect(this.x + 8, this.y + 32, 6, 12);
                    ctx.fillRect(this.x + 18, this.y + 32, 6, 12);
                } else {
                    // Running animation
                    const legOffset = Math.sin(frameCount * 0.3) * 4;
                    ctx.fillRect(this.x + 8, this.y + 32, 6, 14 + legOffset);
                    ctx.fillRect(this.x + 18, this.y + 32, 6, 14 - legOffset);
                }
                
                // Arms
                ctx.fillStyle = '#F5D5C8';
                if (this.isJumping) {
                    // Arms up when jumping
                    ctx.fillRect(this.x + 2, this.y + 10, 6, 4);
                    ctx.fillRect(this.x + 24, this.y + 10, 6, 4);
                } else {
                    const armOffset = Math.sin(frameCount * 0.3) * 3;
                    ctx.fillRect(this.x + 2, this.y + 16 + armOffset, 6, 4);
                    ctx.fillRect(this.x + 24, this.y + 16 - armOffset, 6, 4);
                }
                
                ctx.restore();
            },
            
            jump() {
                if (!this.isJumping && gameState === 'playing') {
                    this.velY = JUMP_FORCE;
                    this.isJumping = true;
                }
            },
            
            update() {
                if (gameState !== 'playing') return;
                
                this.velY += GRAVITY;
                this.y += this.velY;
                
                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.velY = 0;
                    this.isJumping = false;
                }
            }
        };

        // Obstacles (nets)
        let obstacles = [];
        
        // Flying volleyballs
        let flyingBalls = [];
        
        function createFlyingBall() {
            const fromTop = Math.random() > 0.5;
            flyingBalls.push({
                x: canvas.width + 20,
                y: fromTop ? 60 + Math.random() * 40 : 120 + Math.random() * 60,
                size: 20,
                speed: gameSpeed * 1.5 + Math.random() * 2,
                rotation: 0,
                passed: false
            });
        }
        
        function drawVolleyball(ball) {
            ctx.save();
            ctx.translate(ball.x + ball.size/2, ball.y + ball.size/2);
            ctx.rotate(ball.rotation);
            
            // Ball base (white)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(-ball.size/2, -ball.size/2, ball.size, ball.size);
            
            // Ball stripes (blue/yellow like real volleyball)
            ctx.fillStyle = '#1E90FF';
            ctx.fillRect(-ball.size/2, -ball.size/2, ball.size, 4);
            ctx.fillRect(-ball.size/2, ball.size/2 - 4, ball.size, 4);
            
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(-ball.size/2, -2, ball.size, 4);
            
            // Panel lines
            ctx.fillStyle = '#333';
            ctx.fillRect(-1, -ball.size/2, 2, ball.size);
            ctx.fillRect(-ball.size/2, -1, ball.size, 2);
            
            ctx.restore();
        }
        
        function createNet() {
            obstacles.push({
                x: canvas.width + 50,
                y: GROUND_Y - 10,
                width: 16,
                height: 58,
                passed: false
            });
        }

        function drawNet(net) {
            // Pole
            ctx.fillStyle = COLORS.netPole;
            ctx.fillRect(net.x, net.y, 6, net.height);
            ctx.fillRect(net.x + net.width - 6, net.y, 6, net.height);
            
            // Net mesh (white with gaps)
            ctx.fillStyle = COLORS.net;
            for (let row = 0; row < 5; row++) {
                ctx.fillRect(net.x + 4, net.y + 8 + row * 10, net.width - 8, 2);
            }
            for (let col = 0; col < 3; col++) {
                ctx.fillRect(net.x + 4 + col * 5, net.y + 8, 2, 42);
            }
        }

        // Maple leaf (goal)
        const mapleLeaf = {
            x: 6000, // Far away initially - longer level!
            y: GROUND_Y - 20,
            width: 40,
            height: 40,
            reached: false,
            
            draw() {
                ctx.save();
                ctx.fillStyle = COLORS.maple;
                
                // Simplified maple leaf shape using rectangles (pixel art style)
                const lx = this.x;
                const ly = this.y;
                
                // Center stem
                ctx.fillRect(lx + 18, ly + 30, 4, 10);
                
                // Main body
                ctx.fillRect(lx + 14, ly + 10, 12, 20);
                
                // Left points
                ctx.fillRect(lx + 4, ly + 14, 10, 8);
                ctx.fillRect(lx, ly + 18, 8, 4);
                
                // Right points  
                ctx.fillRect(lx + 26, ly + 14, 10, 8);
                ctx.fillRect(lx + 32, ly + 18, 8, 4);
                
                // Top point
                ctx.fillRect(lx + 16, ly, 8, 14);
                ctx.fillRect(lx + 18, ly - 4, 4, 8);
                
                // Side upper points
                ctx.fillRect(lx + 6, ly + 6, 8, 6);
                ctx.fillRect(lx + 26, ly + 6, 8, 6);
                
                ctx.restore();
            },
            
            update() {
                if (gameState === 'playing') {
                    this.x -= gameSpeed;
                }
            }
        };

        // Sun
        function drawSun() {
            const sunX = 560;
            const sunY = 50;
            
            // Glow
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(sunX, sunY, 40, 0, Math.PI * 2);
            ctx.fill();
            
            // Sun body
            ctx.fillStyle = COLORS.sun;
            ctx.fillRect(sunX - 20, sunY - 20, 40, 40);
            
            // Rays (pixel style)
            ctx.fillStyle = COLORS.sunGlow;
            ctx.fillRect(sunX - 4, sunY - 32, 8, 8);
            ctx.fillRect(sunX - 4, sunY + 24, 8, 8);
            ctx.fillRect(sunX - 32, sunY - 4, 8, 8);
            ctx.fillRect(sunX + 24, sunY - 4, 8, 8);
        }

        // Clouds
        let clouds = [
            { x: 100, y: 40, size: 1 },
            { x: 300, y: 60, size: 0.8 },
            { x: 500, y: 30, size: 1.2 }
        ];

        function drawCloud(cloud) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const s = cloud.size;
            ctx.fillRect(cloud.x, cloud.y, 40 * s, 16 * s);
            ctx.fillRect(cloud.x + 8 * s, cloud.y - 8 * s, 24 * s, 8 * s);
            ctx.fillRect(cloud.x + 4 * s, cloud.y + 16 * s, 32 * s, 8 * s);
        }

        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.x -= gameSpeed * 0.3;
                if (cloud.x < -60) {
                    cloud.x = canvas.width + 20;
                    cloud.y = 20 + Math.random() * 50;
                }
            });
        }

        // Ground details (sand texture)
        function drawGround() {
            // Sand base
            ctx.fillStyle = COLORS.sand;
            ctx.fillRect(0, GROUND_Y + 48, canvas.width, 40);
            
            // Sand lighter top
            ctx.fillStyle = COLORS.sandLight;
            ctx.fillRect(0, GROUND_Y + 48, canvas.width, 8);
            
            // Random sand dots
            ctx.fillStyle = COLORS.sandDark;
            for (let i = 0; i < 30; i++) {
                const dotX = (i * 23 + frameCount * 2) % canvas.width;
                ctx.fillRect(dotX, GROUND_Y + 52 + (i % 3) * 8, 2, 2);
            }
        }

        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, COLORS.sky);
            gradient.addColorStop(0.6, COLORS.skyLight);
            gradient.addColorStop(0.7, COLORS.sandLight);
            gradient.addColorStop(1, COLORS.sand);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw elements
            drawSun();
            clouds.forEach(drawCloud);
            drawGround();
            
            if (gameState === 'waiting') {
                // Start screen
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = COLORS.white;
                ctx.font = '24px "Space Mono"';
                ctx.textAlign = 'center';
                ctx.fillText('üèê BEACH JUMP üèê', canvas.width / 2, 100);
                ctx.font = '16px "Space Mono"';
                ctx.fillText('Help Amanda reach the maple leaf!', canvas.width / 2, 140);
                ctx.fillText('Press SPACE or TAP to start', canvas.width / 2, 180);
                
                amanda.draw();
            } else if (gameState === 'playing') {
                frameCount++;
                gameSpeed += GAME_SPEED_INCREMENT;
                
                // Update
                amanda.update();
                updateClouds();
                mapleLeaf.update();
                
                // Spawn obstacles (nets)
                if (frameCount % 90 === 0 && mapleLeaf.x > canvas.width + 200) {
                    createNet();
                }
                
                // Spawn flying volleyballs (every ~150 frames, with some randomness)
                if (frameCount % 150 === 0 && Math.random() > 0.3 && mapleLeaf.x > canvas.width + 300) {
                    createFlyingBall();
                }
                
                // Update flying volleyballs
                flyingBalls.forEach((ball, index) => {
                    ball.x -= ball.speed;
                    ball.rotation += 0.15;
                    
                    // Score when dodged
                    if (!ball.passed && ball.x + ball.size < amanda.x) {
                        ball.passed = true;
                        score += 2; // Bonus for dodging balls!
                        scoreEl.textContent = score;
                    }
                    
                    // Remove off-screen
                    if (ball.x < -30) {
                        flyingBalls.splice(index, 1);
                    }
                    
                    // Collision check
                    if (checkCollision(
                        { x: amanda.x + 8, y: amanda.y + 8, width: 16, height: 38 },
                        { x: ball.x, y: ball.y, width: ball.size, height: ball.size }
                    )) {
                        gameState = 'gameOver';
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('amandaGameHighScore', highScore);
                            highScoreEl.textContent = highScore;
                        }
                    }
                });
                
                // Update obstacles
                obstacles.forEach((net, index) => {
                    net.x -= gameSpeed;
                    
                    // Score when passed
                    if (!net.passed && net.x + net.width < amanda.x) {
                        net.passed = true;
                        score++;
                        scoreEl.textContent = score;
                    }
                    
                    // Remove off-screen
                    if (net.x < -50) {
                        obstacles.splice(index, 1);
                    }
                    
                    // Collision check
                    if (checkCollision(
                        { x: amanda.x + 8, y: amanda.y + 8, width: 16, height: 38 },
                        net
                    )) {
                        gameState = 'gameOver';
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('amandaGameHighScore', highScore);
                            highScoreEl.textContent = highScore;
                        }
                    }
                });
                
                // Check if reached maple leaf
                if (checkCollision(
                    { x: amanda.x, y: amanda.y, width: amanda.width, height: amanda.height },
                    { x: mapleLeaf.x, y: mapleLeaf.y, width: mapleLeaf.width, height: mapleLeaf.height }
                )) {
                    gameState = 'won';
                    score += 50; // Bonus for winning!
                    scoreEl.textContent = score;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('amandaGameHighScore', highScore);
                        highScoreEl.textContent = highScore;
                    }
                }
                
                // Draw game elements
                obstacles.forEach(drawNet);
                flyingBalls.forEach(drawVolleyball);
                mapleLeaf.draw();
                amanda.draw();
                
            } else if (gameState === 'gameOver') {
                // Still draw everything
                obstacles.forEach(drawNet);
                flyingBalls.forEach(drawVolleyball);
                mapleLeaf.draw();
                amanda.draw();
                
                // Game over overlay
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = COLORS.blush;
                ctx.font = 'bold 32px "Space Mono"';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, 120);
                
                ctx.fillStyle = COLORS.white;
                ctx.font = '18px "Space Mono"';
                ctx.fillText(`Score: ${score}`, canvas.width / 2, 160);
                ctx.fillText('Press SPACE to try again', canvas.width / 2, 200);
                
            } else if (gameState === 'won') {
                // Victory!
                obstacles.forEach(drawNet);
                flyingBalls.forEach(drawVolleyball);
                mapleLeaf.draw();
                amanda.draw();
                
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = COLORS.maple;
                ctx.font = 'bold 28px "Space Mono"';
                ctx.textAlign = 'center';
                ctx.fillText('üçÅ YOU MADE IT! üçÅ', canvas.width / 2, 100);
                
                ctx.fillStyle = COLORS.sandDark;
                ctx.font = '18px "Space Mono"';
                ctx.fillText('Amanda reached Canada!', canvas.width / 2, 140);
                ctx.fillText(`Final Score: ${score} (includes +50 bonus!)`, canvas.width / 2, 170);
                ctx.fillText('Press SPACE to play again', canvas.width / 2, 210);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Reset game
        function resetGame() {
            gameState = 'playing';
            score = 0;
            scoreEl.textContent = 0;
            gameSpeed = GAME_SPEED_INITIAL;
            frameCount = 0;
            obstacles = [];
            amanda.y = GROUND_Y;
            amanda.velY = 0;
            amanda.isJumping = false;
            mapleLeaf.x = 5000 + Math.random() * 1500; // Randomize distance - longer level!
            flyingBalls = [];
            mapleLeaf.reached = false;
        }

        // Input handlers
        function handleInput() {
            if (gameState === 'waiting') {
                resetGame();
            } else if (gameState === 'playing') {
                amanda.jump();
            } else if (gameState === 'gameOver' || gameState === 'won') {
                resetGame();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleInput();
            }
        });

        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // Initialize
        highScoreEl.textContent = highScore;
        gameLoop();
    </script>
</body>
</html>
